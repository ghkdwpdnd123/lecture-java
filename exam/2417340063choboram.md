



JVM (Java Virtual Machine)
Java는 플랫폼 독립적인 언어로, JVM을 통해 어느 운영체제에서든 동일한 프로그램을 실행할 수 있습니다. 자바 코드는 컴파일되어 바이트코드로 변환되며, 이 바이트코드는 JVM에서 실행됩니다. JVM은 각 운영체제에 맞게 구현되어 있어, 자바 프로그램이 한 번 작성되면 다양한 환경에서 실행 가능합니다.
GC (Garbage Collection)
Java는 자동 메모리 관리 기능을 제공합니다. **가비지 컬렉터(Garbage Collector, GC)**가 더 이상 사용되지 않는 객체를 자동으로 제거해 메모리 누수를 방지합니다. 이를 통해 개발자는 명시적으로 메모리를 해제할 필요가 없으며, 프로그램이 안정적으로 동작할 수 있습니다. GC는 주기적으로 메모리를 검사하고 사용되지 않는 객체를 회수하여 메모리 공간을 확보합니다.
객체 지향 프로그래밍 (OOP)
Java는 객체 지향 언어로, 프로그램을 객체 단위로 나누어 설계하고 개발합니다. 객체 지향의 핵심 원칙인 캡슐화, 상속, 다형성, 추상화 등을 지원하여, 유지보수성과 재사용성을 높입니다.
플랫폼 독립성
자바의 WORA(Write Once, Run Anywhere) 원칙에 따라, 한 번 작성된 코드는 어떤 플랫폼에서든 수정 없이 실행됩니다. 이것은 JVM 덕분에 가능한데, 컴파일된 바이트코드를 각 운영체제에 맞는 JVM이 해석하여 실행하기 때문입니다.
멀티스레딩 지원
Java는 멀티스레딩을 지원하여, 동시에 여러 작업을 처리할 수 있습니다. 이를 통해 응답성과 성능이 향상되며, 자바는 복잡한 스레드 관련 작업을 비교적 쉽게 처리할 수 있는 라이브러리를 제공합니다.
동적 로딩
Java는 프로그램 실행 중에 필요한 클래스만 로드할 수 있는 동적 로딩을 지원합니다. 이 기능은 프로그램의 초기 로딩 시간을 줄이고, 필요한 시점에만 클래스를 메모리에 로드해 효율적으로 자원을 관리할 수 있습니다.
이러한 특징들 덕분에 Java는 강력하고 범용적으로 사용되는 프로그래밍 언어로 자리 잡고 있습니다.

오버라이딩(Overriding)과 오버로딩(Overloading)에 대해 설명해주세요.

정의: 상속 관계에서 부모 클래스가 가진 메서드를 자식 클래스에서 재정의하는 것을 의미합니다. 부모 클래스의 메서드를 자식 클래스에서 동일한 이름과 매개변수로 재정의하여 새로운 동작을 구현할 수 있습니다.
조건: 메서드의 이름, 매개변수, 반환 타입이 부모 클래스와 동일해야 하며, 부모 메서드보다 더 넓은 범위의 접근 제어자를 가질 수는 있지만 더 좁게는 할 수 없습니다.
사용 목적: 부모 클래스의 메서드를 다형성을 통해 동적으로 호출하거나, 자식 클래스에서 필요한 방식으로 기능을 재구현할 때 사용합니다.


오버로딩(Overloading)
정의: 같은 클래스 내에서 메서드 이름은 동일하지만 서로 다른 매개변수(타입, 개수, 순서)를 가지는 여러 메서드를 정의하는 것을 의미합니다.
조건: 메서드의 이름은 동일하지만, 매개변수의 타입, 개수, 순서가 달라야 합니다. 반환 타입은 달라도 상관없으나, 반환 타입만 다르고 매개변수가 동일한 경우는 허용되지 않습니다.
사용 목적: 동일한 기능을 하는 메서드를 다양한 형태로 호출할 수 있도록 하여 편의성을 높이기 위해 사용합니다.

싱글톤 패턴에 대해 설명해주세요.

싱글톤 패턴(Singleton Pattern)
싱글톤 패턴은 오직 하나의 인스턴스만을 생성하도록 제한하는 디자인 패턴입니다. 프로그램 내에서 해당 클래스의 객체가 단 하나만 존재하도록 하며, 그 객체에 접근할 수 있는 전역적인 접근 포인트를 제공합니다.
주요 특징
하나의 인스턴스: 클래스의 인스턴스가 하나만 존재하게 하여, 어디서든 동일한 객체를 사용할 수 있습니다.
전역적 접근: 싱글톤 객체는 전역적으로 접근 가능하며, 이를 통해 다른 객체들이 싱글톤 객체를 공유할 수 있습니다.
Lazy Initialization: 필요할 때까지 객체를 생성하지 않고, 최초로 접근할 때 객체를 생성하는 방식입니다. 이를 통해 메모리와 자원을 효율적으로 사용할 수 있습니다.

장점
메모리 절약: 동일한 객체를 여러 번 생성할 필요가 없으므로 메모리를 절약할 수 있습니다.
전역 상태 관리: 하나의 인스턴스를 전역적으로 사용할 수 있어, 프로그램 내에서 상태를 쉽게 관리할 수 있습니다.
단점
멀티스레드 환경 문제: 싱글톤 패턴은 여러 스레드에서 동시에 객체를 생성하려고 할 경우, 여러 개의 인스턴스가 생성될 수 있는 문제점이 있습니다. 이를 방지하기 위해 synchronized 키워드 등을 사용하여 스레드 안전성을 보장해야 합니다.
테스트의 어려움: 전역적인 인스턴스는 의존성 주입 등을 어렵게 만들어, 테스트가 힘들어질 수 있습니다.
싱글톤 패턴은 주로 로그 관리, 데이터베이스 연결, 설정 클래스 등에서 많이 사용됩니다.

List와 Map의 차이

1. List
정의: List는 순서가 있는 컬렉션으로, 요소들이 삽입된 순서대로 저장됩니다. 각 요소는 인덱스를 통해 접근할 수 있습니다.
특징:
중복 허용: List는 동일한 값을 여러 번 저장할 수 있습니다.
인덱스 기반 접근: 요소들은 0부터 시작하는 인덱스로 관리되며, 인덱스를 통해 특정 요소에 빠르게 접근할 수 있습니다.
구현체: ArrayList, LinkedList, Vector 등이 있습니다.

2. Map
정의: Map은 키(key)-값(value) 쌍으로 구성된 컬렉션입니다. 각 키는 고유해야 하며, 이를 통해 값에 접근할 수 있습니다.
특징:
중복 키 불허: 동일한 키는 존재할 수 없지만, 값은 중복될 수 있습니다.
키 기반 접근: 키를 통해 값에 접근하며, 특정 키에 대한 값을 빠르게 찾을 수 있습니다.
구현체: HashMap, TreeMap, LinkedHashMap, Hashtable 등이 있습니다.

주요 차이점

구분
List
Map
데이터 구조
순서가 있는 값들의 모음
키-값 쌍으로 구성
순서
삽입된 순서대로 유지됨
순서를 보장하지 않음 (LinkedHashMap 제외)
중복 허용
중복된 요소 허용
중복 불가, 값은 중복 가능
접근 방식
인덱스 기반
키를 통해 값에 접근
사용 목적
순차적으로 데이터를 관리하고 접근할 때
키를 통해 값을 빠르게 검색할 때



String, StringBuffer, StringBuilder의 차이를 설명해주세요.

1. String, StringBuffer, StringBuilder의 차이점
String: 문자열을 수정할 수 없는 불변 객체입니다. 한 번 생성되면 변경할 수 없으며, 변경하려면 새로운 객체를 만들어야 해서 메모리와 성능에 부담을 줄 수 있습니다.
StringBuffer: 문자열을 수정할 수 있는 가변 객체로, 스레드 안전성을 보장합니다. 즉, 여러 스레드가 동시에 작업할 때 안전하게 사용할 수 있지만, 그로 인해 상대적으로 속도가 느립니다.
StringBuilder: StringBuffer와 마찬가지로 가변 객체이지만, 스레드 안전성이 필요 없는 경우 더 빠르게 작동합니다. 단일 스레드 환경에서 사용하기 적합합니다​.STACK ABUSE TRAINING HUB

2. Restful API에 대해 설명해주세요.
RESTful API는 REST(Representational State Transfer) 원칙을 따르는 API입니다. HTTP 메서드(GET, POST, PUT, DELETE)를 사용해 CRUD 작업을 수행하며, 클라이언트와 서버 간에 상태를 유지하지 않는 방식으로 통신합니다. RESTful API는 보통 JSON 또는 XML 형식으로 데이터를 주고받으며, 웹 애플리케이션에서 널리 사용됩니다.



3.Call By Value와 Call By Reference의 차이에 대해 설명해주세요.
Call by Value: 메서드에 값을 전달할 때, 해당 값의 복사본이 전달되므로 원래 변수에는 영향을 주지 않습니다. Java에서는 기본 자료형(primitive type)이 Call by Value 방식으로 전달됩니다.
Call by Reference: 참조를 전달하는 방식으로, 참조된 객체의 값을 메서드에서 수정할 수 있습니다. Java에서 객체는 Call by Reference 방식으로 전달되지만, 실제로는 참조의 복사본이 전달됩니다.
